---
title: "Le vote des quartiers politiques de la ville de la Métropole de Lyon"
subtitle: "Analyse des élections législatives et présidentielles de 2017 et 2022"
author: "Datactivist"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
    rmarkdown::html_document:
      #number_sections: true
      #self_contained: false
      theme: paper
      toc: true
      toc_depth: 4
      collapsed: true
      smooth_scroll: true
      css: !expr here::here("préparation/styles.css")
      includes:
        in_header: !expr here::here("préparation/header.html")
        after_body: !expr here::here("préparation/footer.html")
---

```{r setup, include=FALSE}
# Paramètres généraux
knitr::opts_chunk$set(
	eval = TRUE,
	echo = FALSE,
	fig.align = "center",
	fig.show = "hold",
	message = FALSE,
	warning = FALSE,
	collapse = TRUE,
	out.width = "100%",
	results = "asis"
)
```

```{r logo}
# Logo Datactivist haut de page
htmltools::img(src = "https://nextcloud.datactivist.coop/s/o53wzfMNnFosQni/preview", 
               alt = 'logo', 
               style = 'position:absolute; top:0; left:0.5; padding-top:10px;') #padding=taille des espaces autour
```

# Préambule


```{r libraries et données, include=FALSE}
# Librairies
library(sf)
library(here)
library(gridExtra)
#remotes::install_github("r-spatial/mapview", dependencies = TRUE)
library(mapview)
library(leafpop)
library(leafsync)
library(ggtext)
library(tools)
library(RColorBrewer)
library(tidyverse)
library(FactoMineR)
library(factoextra)
library(corrplot)
library(see)
library(plotly)
library(glue)

# Données
bv_2017 <- st_read(here("output_data", "bv_2017.gpkg"))
bv_communes_2022 <- st_read(here("output_data", "bv_communes_2022.gpkg"))

bv_l17_t1 <- st_read(here("output_data", "bv_grandlyon_l2017_t1_res.gpkg")) |> mutate(id=NA)
bv_l22_t1 <- st_read(here("output_data", "bv_grandlyon_l2022_t1_res.gpkg"))
bv_p17_t1 <- st_read(here("output_data", "bv_grandlyon_p2017_t1_res.gpkg")) |> mutate(id=NA)
bv_p17_t2 <- st_read(here("output_data", "bv_grandlyon_p2017_t2_res.gpkg")) |> mutate(id=NA)
bv_p22_t1 <- st_read(here("output_data", "bv_grandlyon_p2022_t1_res.gpkg"))
bv_p22_t2 <- st_read(here("output_data", "bv_grandlyon_p2022_t2_res.gpkg"))

qpv_l17_t1 <- st_read(here("output_data", "qpv69_leg_17_t1.gpkg"))
qpv_l22_t1 <- st_read(here("output_data", "qpv69_leg_22_t1.gpkg"))
qpv_p17_t1 <- st_read(here("output_data", "qpv69_pres_17_t1.gpkg"))
qpv_p17_t2 <- st_read(here("output_data", "qpv69_pres_17_t2.gpkg"))
qpv_p22_t1 <- st_read(here("output_data", "qpv69_pre_22_t1.gpkg"))
qpv_p22_t2 <- st_read(here("output_data", "qpv69_pre_22_t2.gpkg"))

# Fonction export des graphiques statiques
saving_plot <- function(graph, name, width, height) {
  ggsave(file = glue("Save_graphs/{name}.png"), plot=graph, width=width, height=height)
}
```

## Localisation des BV

```{r évolution des BV}
# Jointure des 2 bases pour voir les différences
evolution_bv <- full_join(bv_2017 |> as.data.frame() |> 
                              mutate(annee = "2017",
                                     real_id_2017 = bureau_vote_id,
                                     bureau_vote_id = case_when(substr(bureau_vote_id, 1, 4) == "6938" ~ paste0("69123", substr(bureau_vote_id, 6, 9)),
                                                                .default = bureau_vote_id)),
                          bv_communes_2022 |> as.data.frame() |> select(-c(type, id)) |> mutate(annee = "2022"), 
                          by = "bureau_vote_id", suffix = c("_2017", "_2022")) |>
    mutate(evol_bv = case_when(geom_2017 == geom_2022 ~ "Bureaux de votes identiques",
                               geom_2017 != geom_2022 ~ "Bureaux de votes redécoupés",
                               is.na(annee_2017) ~ "Bureaux de votes créés",
                               is.na(annee_2022) ~ "Bureaux de votes supprimés", 
                              .default = NA)) |> 
    select(-c(annee_2017, annee_2022)) 
evolution_bv <- evolution_bv |> 
  mutate(is_intersect = st_intersects(evolution_bv$geom_2017, qpv_p17_t1$geom, sparse = FALSE),
           is_intersect = asplit(is_intersect, 1)) |> 
    unnest_wider(c(is_intersect), names_sep = "_") |> 
    mutate(perim_met = case_when(if_any(contains("is_intersect"), function(x) {x == "TRUE"}) ~ "BV - QPV",
                                if_all(contains("is_intersect"), function(x) {x == "FALSE"}) ~ "BV")) |> 
    select(-starts_with("is_intersect"))
evolution_bv_longer <- evolution_bv |> 
    pivot_longer(cols = c(geom_2017, geom_2022), values_to = "geom", names_prefix = "geom_", names_to = "annee") |> 
    mutate(evol_bv_neutre_2017 = case_when(annee == "2017" ~ "Bureaux de votes identiques",
                                           .default = evol_bv),
           evol_bv_neutre_2017 = factor(evol_bv_neutre_2017, 
                                        levels = c("Bureaux de votes identiques", "Bureaux de votes redécoupés", 
                                                "Bureaux de votes supprimés", "Bureaux de votes créés")))

# Visualisation des découpages 2017 vs. 2022
graph <- evolution_bv_longer |> 
    ggplot() +
        geom_sf(aes(geometry = geom, fill = evol_bv_neutre_2017)) +
        scale_fill_manual(values = c("Bureaux de votes identiques" = "wheat2", "Bureaux de votes redécoupés" = "wheat3", 
                                     "Bureaux de votes créés" = "brown3", "Bureaux de votes supprimés" = "#999999")) +
        labs(title = "Localisation des bureaux de votes de la métropole de Lyon", 
             subtitle = "Entre 2017 et 2022, 5 bureaux de vote (BV) sont restés parfaitement identiques, \n861 ont été redécoupés, 30 ont été créés et 1 a été supprimé.", 
             fill = "",
             caption = "Source: Données extraites des listes électorales et Cartelec, Céline COLANGE ©UMR CNRS 6266 IDEES, Université de Rouen \nRéalisation: Gombin J., Thierry D. Analyse du vote des QPV de la métropole de Lyon en 2017 et 2022") +
        facet_wrap(~annee) +
        theme_void() +
        guides(fill = guide_legend(override.aes = list(lwd = 1, col = "white"))) +
        theme(plot.title = element_text(face = "bold"),
              plot.caption = element_text(face = "italic", hjust = 0),
              strip.text = element_text(face = "bold", size = 12, margin = margin(20,0,0,0)))
graph
saving_plot(graph, "BV_2017_2022", 12, 7)
# nom des comm de plus de 20.000 hab
# nombre d'inscrits / nombre d'habitants en âge de voter en popup -> Joël
```


```{r evol BV interactif}
# Même dataviz interactive
p2017 <- evolution_bv_longer |> 
    filter(annee == "2017") |> 
    st_as_sf() |> 
    mapview(zcol = "evol_bv_neutre_2017",
      layer.name = "Bureaux de votes en 2017",
      legend = FALSE, 
      basemaps.color.shuffle = FALSE, map.types = "CartoDB.Positron",
      col.regions = c("Bureaux de votes identiques" = "wheat2", "Bureaux de votes redécoupés" = "wheat3", 
                      "Bureaux de votes supprimés" = "#999999", "Bureaux de votes créés" = "brown3"),
      popup = popupTable(evolution_bv_longer, zcol = c("code_insee_2017")))
p2022 <- evolution_bv_longer |> 
    filter(annee == "2022") |> 
    st_as_sf() |> 
    mapview(zcol = "evol_bv_neutre_2017",
      layer.name = "Bureaux de votes en 2022",
      legend = TRUE, 
      basemaps.color.shuffle = FALSE, map.types = "CartoDB.Positron",
      col.regions = c("Bureaux de votes identiques" = "wheat2", "Bureaux de votes redécoupés" = "wheat3", 
                      "Bureaux de votes supprimés" = "#999999", "Bureaux de votes créés" = "brown3"),
      popup = popupTable(evolution_bv_longer, zcol = c("code_insee_2022")))
sync(p2017,p2022)
mapshot(p2017, url = "Save_cartos/carte_BV_2017.html")
mapshot(p2022, url = "Save_cartos/carte_BV_2022.html")
#p2017 | p2022
# titre, sous-titre, caption
# popup
```

`r nrow(bv_2017)` bureaux de vote en 2017 et `r nrow(bv_communes_2022)` en 2022, soit `r nrow(bv_communes_2022) - nrow(bv_2017)` de différence. 

## Contrôle du redécoupage des BV

```{r Inscrits BV 17-22, out.width='60%'}
# Nuage de points sur le nombre d'inscrits dans le BV 2017 et 2022
graph <- full_join(bv_p17_t1 |> as.data.frame(),
          bv_p22_t1 |> as.data.frame(), 
          by = "bureau_vote_id", suffix = c("_2017", "_2022")) |> 
  select(bureau_vote_id, Inscrits_2017, Inscrits_2022) |> 
  ggplot(aes(x = Inscrits_2017, y = Inscrits_2022)) +
  geom_point(alpha = .5) +
  geom_abline(col = "red") +
  labs(x = "Nombre d'inscrits en 2017", y = "Nombre d'inscrits en 2022",
       title = "Comparaison du nombre d'inscrits dans les bureaux de vote entre 2017 et 2022",
       subtitle = "Personnes inscrites au premier tour des élections présidentielles dans 2 années") +
  xlim(500,NA) + ylim(500,NA) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 1),
        plot.subtitle = element_text(face = "italic"))
graph
saving_plot(graph, "Redecoupage_BV",7, 5)
```

```{r eval=FALSE, include=FALSE}
# Taux de superposition spatiale
  # Création d'objets vides
inter_bv <- 0
inter_save <- 0
area_commune <- 0
area_2017 <- 0
ratio <- 0
  # Calcul du ratio
for (i in 1:52) {
  evolution_bv_sf <- evolution_bv |> st_as_sf() |> filter(row_number() == i)
  inter_bv <- st_intersection(evolution_bv_sf$geom_2017, evolution_bv_sf$geom_2022)
  inter_save[i] <- inter_bv
  area_commune[i] <- st_area(inter_bv)
  area_2017[i] <- st_area(evolution_bv_sf$geom_2017)
  ratio[i] <- area_commune[i] / area_2017[i] *100
  inter_bv <- 0
}

evolution_bv_sf <- evolution_bv |> st_as_sf() |> filter(row_number() < 53)
inter_bv <- st_intersection(evolution_bv_sf$geom_2017, evolution_bv_sf$geom_2022)
plot(evolution_bv_sf$geom_2017, axes = TRUE)
plot(evolution_bv_sf$geom_2022, add = TRUE)
plot(inter_bv, add = TRUE, col = 'red')
# voir si QPV sont dans BV
# mapview des BV avec ratios < 97%
```


## Localisation des QPV

```{r localisation QPV, echo=FALSE}
# Prépa données
evolution_bv_qpv <- rbind(evolution_bv_longer |> filter(annee == "2017") |> rename(id = bureau_vote_id) |> 
                              mutate(type = "Bureaux de vote") |> select(id, type, annee, geom),
                          evolution_bv_longer |> filter(annee == "2022") |> rename(id = bureau_vote_id) |> 
                              mutate(type = "Bureaux de vote") |> select(id, type, annee, geom),
                          qpv_p17_t1 |> rename(id = CODE_QP) |> as.data.frame() |> 
                              mutate(type = "Quartiers prioritaires", annee = "2017") |> select(id, type, annee, geom),
                          qpv_p22_t1 |> rename(id = CODE_QP) |> as.data.frame() |> 
                              mutate(type = "Quartiers prioritaires", annee = "2022") |> select(id, type, annee, geom))

# Visualisation des QPV 2017 vs. 2022
# evolution_bv_qpv |> 
#     ggplot() +
#         geom_sf(aes(geometry = geom, fill = type)) +
#         scale_fill_manual(values = c("Bureaux de vote" = "wheat2", "Quartiers prioritaires" = "brown3")) +
#         labs(title = "Localisation des quartiers prioritaires de la ville de Lyon \nparmi les bureaux de vote", 
#              subtitle = "Le découpage des quartiers prioritaires n'a pas évolué entre 2017 et 2022.", fill = "",
#              caption = "Source: Données extraites des listes électorales et Cartelec, Céline COLANGE ©UMR CNRS 6266 IDEES, Université de Rouen \nRéalisation: Gombin J., Thierry D. Analyse du vote des QPV de la métropole de Lyon entre 2017 et 2022") +
#         facet_wrap(~annee) +
#         theme_void() +
#         guides(fill = guide_legend(override.aes = list(lwd = 1, col = "white"))) +
#         theme(plot.title = element_text(face = "bold"),
#               plot.caption = element_text(face = "italic", hjust = 0),
#               strip.text = element_text(face = "bold", size = 12, margin = margin(20,0,0,0)))
# version intéractive avec nb habitants et inscrits

metropole <- st_read("https://data.grandlyon.com/geoserver/metropole-de-lyon/ows?SERVICE=WFS&VERSION=2.0.0&request=GetFeature&typename=metropole-de-lyon:adr_voie_lieu.adrmetropole&outputFormat=application/json&SRSNAME=EPSG:4171&sortBy=gid")

contours_qpv <- mapview(metropole, alpha.regions = 0.01,
            legend = FALSE,
            map.types = "CartoDB.Positron", label = NA, popup = FALSE) +
    mapview(qpv_p17_t1 |>
                select(CODE_QP, Inscrits) |> 
                mutate(Inscrits = round(Inscrits)) |>
                left_join(pop_qpv |> select(codeQPV, `Nom du QPV` = libQPV, `Commune` = listeLibDepcom), by = c("CODE_QP" = "codeQPV")),
      layer.name = "QPV",
      legend = FALSE,
      map.types = "CartoDB.Positron",
      homebutton = FALSE) 

mapshot(contours_qpv, url = "Save_cartos/carte_QPV_contours.html")

p2017 <- evolution_bv_qpv |> 
    st_as_sf() |> 
    mapview(zcol = "type",
      layer.name = "Bureaux de votes en 2017",
      legend = FALSE, 
      basemaps.color.shuffle = FALSE, map.types = "CartoDB.Positron",
      col.regions = c("Bureaux de vote" = "wheat2", "Quartiers prioritaires" = "brown3"))
p2022 <- evolution_bv_qpv |> 
    st_as_sf() |> 
    mapview(zcol = "type",
      layer.name = "Bureaux de votes en 2022",
      legend = TRUE, 
      basemaps.color.shuffle = FALSE, map.types = "CartoDB.Positron",
      col.regions = c("Bureaux de vote" = "wheat2", "Quartiers prioritaires" = "brown3"))
sync(p2017,p2022)
mapshot(p2017, url = "Save_cartos/carte_QPV_2017.html")
mapshot(p2022, url = "Save_cartos/carte_QPV_2022.html")
```


<br>

<br>

## Population, inscrits, votants{.tabset}

```{r include=FALSE}
# Import données externes
pop_qpv <- st_read(here("output_data", "data_pop_qpv_2018.csv"))
pop_communes <- read_delim("https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/demographyref-france-pop-legale-commune-arrondissement-municipal/exports/csv?lang=fr&facet=facet(name%3D%22reg_code%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22reg_name%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22com_arm_code%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22com_arm_name%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22dep_code%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22arrdep_code%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22epci_name%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22epci_code%22%2C%20disjunctive%3Dtrue)&facet=facet(name%3D%22dep_name%22%2C%20disjunctive%3Dtrue)&refine=dep_code%3A%2269%22&timezone=Europe%2FBerlin&use_labels=true&delimiter=%3B", ";") |> 
  mutate(code_insee = as.character(`Code Officiel Commune / Arrondissement Municipal`))
pop_communes_select <- pop_communes |> 
    select(code_insee, `Population municipale`) |> 
    rename(Population = `Population municipale`)
```



```{r test_facet_cens, fig.height=7}
graph <- rbind(
    rbind(qpv_l17_t1 |> 
        left_join(pop_qpv |> select(codeQPV, popMuniQPV),
                          by = c("CODE_QP" = "codeQPV")) |> 
        select(CODE_QP, popMuniQPV, Inscrits, Votants) |> 
        mutate(type = "Législatives 2017 tour 1") |> 
        rename(id = CODE_QP, Population = popMuniQPV), 
      qpv_l22_t1 |> 
        left_join(pop_qpv |> select(codeQPV, popMuniQPV),
                          by = c("CODE_QP" = "codeQPV")) |> 
        select(CODE_QP, popMuniQPV, Inscrits, Votants) |> 
        mutate(type = "Législatives 2022 tour 1") |> 
        rename(id = CODE_QP, Population = popMuniQPV),
      qpv_p17_t1 |> 
        left_join(pop_qpv |> select(codeQPV, popMuniQPV),
                          by = c("CODE_QP" = "codeQPV")) |> 
        select(CODE_QP, popMuniQPV, Inscrits, Votants) |> 
        mutate(type = "Présidentielles 2017 tour 1") |> 
        rename(id = CODE_QP, Population = popMuniQPV),
      qpv_p22_t1 |> 
        left_join(pop_qpv |> select(codeQPV, popMuniQPV),
                          by = c("CODE_QP" = "codeQPV")) |> 
        select(CODE_QP, popMuniQPV, Inscrits, Votants) |> 
        mutate(type = "Présidentielles 2022 tour 1") |> 
        rename(id = CODE_QP, Population = popMuniQPV),
      qpv_p17_t2 |> 
        left_join(pop_qpv |> select(codeQPV, popMuniQPV),
                          by = c("CODE_QP" = "codeQPV")) |> 
        select(CODE_QP, popMuniQPV, Inscrits, Votants) |> 
        mutate(type = "Présidentielles 2017 tour 2") |> 
        rename(id = CODE_QP, Population = popMuniQPV),
      qpv_p22_t2 |> 
        left_join(pop_qpv |> select(codeQPV, popMuniQPV),
                          by = c("CODE_QP" = "codeQPV")) |> 
        select(CODE_QP, popMuniQPV, Inscrits, Votants) |> 
        mutate(type = "Présidentielles 2022 tour 2") |> 
        rename(id = CODE_QP, Population = popMuniQPV)) |> 
  group_by(type) |> 
  mutate(Population = sum(as.numeric(Population), na.rm = T),
         Inscrits = sum(Inscrits, na.rm = T),
         Votants = sum(Votants, na.rm = T)) |> 
  as.data.frame() |> 
  select(-c(id, geom)) |> 
  distinct() |> 
  mutate(total = Population) |> 
  pivot_longer(cols = -c(type, total), names_to = "compte", values_to = "nb") |> 
  mutate(percent = nb/total*100,
         percent_lbl = paste0(round(percent), " %"),
         compte = fct_reorder(compte, nb, .desc = TRUE),
         scope = "QPV"),
      rbind(bv_l17_t1 |> 
            mutate(type = "Législatives 2017 tour 1", Population = 1386000) |> 
            select(code_insee, Population, Inscrits, Votants, type),
          bv_l22_t1 |> 
            mutate(type = "Législatives 2022 tour 1", Population = 1411570) |> 
            select(code_insee, Population, Inscrits, Votants, type),
          bv_p17_t1 |> 
            mutate(type = "Présidentielles 2017 tour 1", Population = 1386000) |> 
            select(code_insee, Population, Inscrits, Votants, type),
          bv_p22_t1 |> 
            mutate(type = "Présidentielles 2022 tour 1", Population = 1411570) |> 
            select(code_insee, Population, Inscrits, Votants, type),
          bv_p17_t2 |> 
            mutate(type = "Présidentielles 2017 tour 2", Population = 1386000) |> 
            select(code_insee, Population, Inscrits, Votants, type),
          bv_p22_t2 |> 
            mutate(type = "Présidentielles 2022 tour 2", Population = 1411570) |> 
            select(code_insee, Population, Inscrits, Votants, type)) |> 
      group_by(type) |> 
      mutate(Inscrits = sum(Inscrits, na.rm = T),
             Votants = sum(Votants, na.rm = T)) |> 
      as.data.frame() |> 
      select(-c(code_insee, geom)) |> 
      distinct() |> 
      mutate(total = Population) |> 
      pivot_longer(cols = -c(type, total), names_to = "compte", values_to = "nb") |> 
      mutate(percent = nb/total*100,
         percent_lbl = paste0(round(percent), " %"),
         compte = fct_reorder(compte, nb, .desc = TRUE),
         scope = "Tous BV")
) |>
    ggplot(aes(x = compte, y = percent)) +
    geom_bar(aes(fill = factor(scope, levels = c("Tous BV", "QPV"))), stat = "identity", position = position_dodge(), width = .6) +
    labs(x = "",
         title = "Le poids des votants dans la population est systématiquement\nplus faible dans les QPV", 
         caption = "Sources : INSEE (recensement de la population 2018), Ministère de l'intérieur.") +
    theme_classic() +
    theme(legend.position = "bottom",
          text = element_text(family = "Monserrat", size = 12),
          plot.title = element_text(face = "bold"),
          axis.title.y = element_blank(),
          panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"),
          axis.line.y = element_blank(),
          axis.ticks.y = element_blank()) +
    scale_fill_manual(values = c("Tous BV" = "wheat2", "QPV" = "brown3")) +
    facet_wrap(~type, ncol = 2, scales='free') +
    scale_y_continuous(labels = scales::comma) +
    labs(fill = "Territoire")
graph
saving_plot(graph, "population_inscrits_votants", 7, 9)
```


```{r age_et_nationalite}



# QPV
# download.file("https://www.insee.fr/fr/statistiques/fichier/7456573/estimations-demographiques_2019_V2.xlsx", here("data", "estimations-demographiques_2019_V2.xlsx"))
# demo_qpv <- readxl::read_xlsx(here("data", "estimations-demographiques_2019_V2.xlsx"), sheet = "Données QPV", skip = 5)
# 
# # filtre pour la métropole
# demo_qpv <- demo_qpv |> 
#     semi_join(qpv_l17_t1, by = join_by(codeGeo == CODE_QP))


qpv_demo <- tribble(
    ~ID,                 ~partPop0_14, ~partPop15_24, ~partPop25_59, ~partPop60_74, ~partPop75p, ~etrangers,
    "QPV",               26.5        , 14.1         , 41.4         , 11.8         , 6.3        , 26.3                     
)

# Métropole

download.file("https://www.insee.fr/fr/statistiques/fichier/6456157/BTX_TD_POP1B_2019.zip", here("data", "BTX_TD_POP1B_2019.zip"))
unzip(here("data", "BTX_TD_POP1B_2019.zip"), exdir = here("data"))
demo_metro <- readxl::read_xlsx(here("data", "BTX_TD_POP1B_2019.xlsx"), sheet = "COM", skip = 10)
# filtre pour la métropole
demo_metro <- demo_metro |>
    semi_join(bv_communes_2022, by = join_by(CODGEO == code_insee))

demo_metro <- demo_metro |>
    pivot_longer(cols = !c(CODGEO, LIBGEO), names_to = "sexe_age", values_to = "count") |>
    separate_wider_delim(sexe_age, delim = "_", names = c("sexe", "age")) |>
    mutate(sexe = str_extract(sexe, "SEXE([12])", group = 1),
           age = as.integer(str_extract(age, "AGED100([0-9]{3})", group = 1))) |>
    group_by(CODGEO, LIBGEO, age) |>
    summarise(count = sum(count)) |> 
    ungroup() |>
    mutate(age_group = case_when(age <= 14 ~ "0_14",
                                 age > 14 & age <= 24 ~ "15_24",
                                 age > 24 & age <= 59 ~ "25_59",
                                 age > 59 & age <= 74 ~ "60_74",
                                 age > 74 ~ "75p",
                                 TRUE ~ NA)) |>
    group_by(age_group) |>
    summarise(count = sum(count)) |>
    mutate(part = count / sum(count) * 100) |>
    select(-count) |>
    pivot_wider(names_from = age_group, values_from = part, names_prefix = "partPop") |>
    mutate(ID = "Métropole")

# nationalité dans les communes de la métropole
download.file("https://www.insee.fr/fr/statistiques/fichier/6454329/BTX_TD_NAT1_2019.zip", here("data", "BTX_TD_NAT1_2019.zip"))

unzip(here("data", "BTX_TD_NAT1_2019.zip"), exdir = here("data"))

natio_metro <- readxl::read_xlsx(here("data", "BTX_TD_NAT1_2019.xlsx"), sheet = "COM", skip = 10)
natio_metro <- natio_metro |>
    semi_join(bv_communes_2022, by = join_by(CODGEO == code_insee))

natio_metro <- natio_metro |>
    pivot_longer(cols = !c(CODGEO, LIBGEO), names_to = "age_nat_sexe", values_to = "count") |>
    separate_wider_delim(age_nat_sexe, delim = "_", names = c("age", "nat", "sexe")) |>
    group_by(nat) %>% 
    summarise(count = sum(count)) |>
    mutate(etrangers = count / sum(count) * 100) |>
    filter(nat %in% "INATC2") |> 
    mutate(ID = "Métropole") |>
    select(-nat, -count)

demo_metro <- demo_metro %>% 
    left_join(natio_metro, by = "ID")

demo <- bind_rows(demo_metro, qpv_demo)

graph <- demo %>% 
    pivot_longer(cols = !ID, 
                 names_to = "variable",
                 values_to = "valeur") |>
    mutate(variable = str_replace(variable, "partPop", ""),
           variable = str_replace(variable, "_", " - "),
           variable = case_when(variable %in% "75p" ~ "75 ans et +",
                                variable %in% "etrangers" ~ "étrangers",
                                TRUE ~ paste0(variable, " ans"))) |>
    ggplot(aes(x = variable, y = valeur)) +
        geom_bar(aes(fill = ID), stat = "identity", position = "dodge") +
        labs(x = "",
             y = "",
         title = "La population des QPV compte plus de jeunes et plus d'étrangers",
         caption = "Source : INSEE (recensement de la population 2019)") +
    theme_classic() +
    theme(legend.position = "bottom",
          text = element_text(family = "Monserrat", size = 12),
          plot.title = element_text(face = "bold"),
          axis.title.y = element_blank(),
          panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"),
          axis.line.y = element_blank(),
          axis.ticks.y = element_blank()) +
    scale_fill_manual(values = c("Métropole" = "wheat2", "QPV" = "brown3")) +
    scale_y_continuous(labels = scales::percent) +
    labs(fill = "Territoire")
graph
saving_plot(graph, "population_age_etrangers", 7, 9)



```


# Présentation des données

## Distribution des votes{.tabset}

```{r function_violinplot}
violinplot_comp <- function(bv, qpv, elections, interpretation, min_x, max_x){
    common_cols <- intersect(colnames(bv), colnames(qpv))
    bv <- bv |> left_join(evolution_bv |> select(bureau_vote_id, perim_met), by = 'bureau_vote_id')
    bv_all <- bv |> as.data.frame() |> rename(old_id = id, id = bureau_vote_id) |> 
      select(id, common_cols, -ends_with(c(".ins", ".exp"))) |> mutate(type = "Ensemble métropole") |> select(-geom)
    bv_hors_qpv <- bv |> as.data.frame() |> filter(perim_met != "BV - QPV") |> rename(old_id = id, id = bureau_vote_id) |> 
      select(id, common_cols, -ends_with(c(".ins", ".exp"))) |> mutate(type = "Métropole hors QPV") |> select(-geom)
    qpv <- qpv |> as.data.frame() |> rename(id = CODE_QP) |> select(id, common_cols, -ends_with(c(".ins", ".exp"))) |> 
      mutate(type = "Quartiers prioritaires") |> select(-geom)
    rbind(bv_all, bv_hors_qpv, qpv)|> 
        pivot_longer(cols = -c(id, type, Inscrits), values_to = "nb_pers", names_to = "vote") |> 
        mutate(percent_inscrits = nb_pers/Inscrits*100,
               order_false_percent = case_when(vote == "Abstentions" ~ 150,
                                               vote == "Blancs" ~ 125,
                                               vote == "Nuls" ~ 100,
                                               .default = percent_inscrits),
               vote = str_replace_all(vote, "\\.", " "),
               # vote = toTitleCase(tolower(vote)),
               vote = fct_reorder(vote, order_false_percent, .desc = T)) |> 
        filter(!vote %in% c("Votants", "Exprimés")) |>
        ggplot(aes(x = type, y = percent_inscrits, fill = type)) +
            geom_violinhalf(linewidth = .3) +
            #geom_jitter(shape=16, position=position_jitter(0.2), alpha = .1) +
            facet_wrap(~vote, scales='free_x') +
            scale_y_continuous(limits=c(min_x, max_x)) +
            scale_fill_manual(values = c("Ensemble métropole" = "wheat3", "Métropole hors QPV" = "wheat2", 
                                         "Quartiers prioritaires" = "brown3")) +
            labs(title = paste0("Comparaison de la distribution des votes entre BV et QPV \n", elections), 
                 subtitle = interpretation, fill = "",
                 caption = "Source: Données extraites des listes électorales et Cartelec, \nCéline COLANGE ©UMR CNRS 6266 IDEES, Université de Rouen \nRéalisation: Gombin J., Thierry D. Analyse du vote des QPV de la métropole de Lyon en 2017 et 2022",
                 y = "Pourcentage d'inscrits", x = "Vote") +
            coord_flip() +
            theme_classic() +
            theme(plot.title = element_text(face = "bold"),
                  plot.caption = element_text(face = "italic", hjust = 0),
                  strip.text = element_text(color = "black", face = "bold"),
                  legend.position = "none",
                  axis.title.y = element_blank(),
                  panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"),
                  axis.line.x = element_blank(),
                  axis.ticks.x = element_blank())
}
```


```{r function_barplot}

barplot_comp <- function(bv, qpv, elections, interpretation, min_x, max_x){
    common_cols <- intersect(colnames(bv), colnames(qpv))
    bv <- bv |> 
        left_join(evolution_bv |> select(bureau_vote_id, perim_met), 
                  by = 'bureau_vote_id')
    bv_all <- bv |> as.data.frame() |> rename(old_id = id, id = bureau_vote_id) |> 
      select(id, common_cols, -ends_with(c(".ins", ".exp"))) |> mutate(type = "Ensemble métropole") |> select(-geom)
    qpv <- qpv |> as.data.frame() |> rename(id = CODE_QP) |> select(id, common_cols, -ends_with(c(".ins", ".exp"))) |> 
      mutate(type = "Quartiers prioritaires") |> select(-geom)
    bind_rows(bv_all, qpv)|> 
        pivot_longer(cols = -c(id, type, Inscrits), values_to = "nb_pers", names_to = "vote") |> 
        group_by(type, vote) |>
        summarise(nb_pers = sum(nb_pers), Inscrits = sum(Inscrits)) |>
        mutate(percent_inscrits = nb_pers/Inscrits*100,
               order_false_percent = case_when(vote == "Abstentions" ~ 150,
                                               vote == "Blancs" ~ 125,
                                               vote == "Nuls" ~ 100,
                                               .default = percent_inscrits),
               vote = str_replace_all(vote, "\\.", " "),
               # vote = toTitleCase(tolower(vote)),
               vote = fct_relevel(vote, rev(c("Abstentions", "Blancs", "Nuls", "ARTHAUD", "CHEMINADE", "POUTOU", "MÉLENCHON", "HAMON", "MACRON", "FILLON", "LASSALLE", "DUPONT AIGNAN", "ASSELINEAU", "LE PEN")))) |> 
        filter(!vote %in% c("Votants", "Exprimés")) |>
        ggplot(aes(x = vote, y = percent_inscrits, fill = type)) +
            geom_bar(stat = "identity", position = "dodge") +
            scale_y_continuous(limits=c(min_x, max_x)) +
            scale_fill_manual(values = c("Ensemble métropole" = "wheat3", 
                                         "Quartiers prioritaires" = "brown3")) +
            labs(title = interpretation, 
                 subtitle = paste0("Comparaison des votes en % des inscrits entre BV et QPV \n", elections), 
                 caption = "Source: Données extraites des listes électorales et Cartelec, \nCéline COLANGE ©UMR CNRS 6266 IDEES, Université de Rouen \nRéalisation: Gombin J., Thierry D. Analyse du vote des QPV de la métropole de Lyon en 2017 et 2022", y = "en % des inscrits",
                 fill = "Territoire") +
            theme_classic() +
            theme(plot.title = element_text(face = "bold"),
                  plot.caption = element_text(face = "italic", hjust = 0),
                  strip.text = element_text(color = "black", face = "bold"),
                  legend.position = "bottom",
                  axis.title.y = element_blank(),
                  panel.grid.major.x = ggplot2::element_line(color = "#cbcbcb"),
                  axis.line.y = element_blank(),
                  axis.ticks.y = element_blank()) +
            coord_flip()

}

```


### Pres.17 tour 1

```{r fig.height=10}
graph <- violinplot_comp(bv_p17_t1, qpv_p17_t1, "au premier tour des présidentielles de 2017", "Les QPV présentent un profil électoral assez homogène\net marqué par le poids de l'abstention.", 0, 50)
graph
saving_plot(graph, "violin_p17_t1", 7, 10)
```

### Pres.17 tour 2

```{r fig.height=5}
graph <- violinplot_comp(bv_p17_t2, qpv_p17_t2, "au second tour des présidentielles de 2017", "", 0, 60)
graph
saving_plot(graph, "violin_p17_t2", 7, 6)
```

### Leg.17 tour 1

```{r fig.height=10}
graph <- violinplot_comp(bv_l17_t1, qpv_l17_t1, "au premier tour des législatives de 2017", "", 0, 80)
graph
saving_plot(graph, "violin_l17_t1", 7, 10)
```


### Pres.22 tour 1

```{r fig.height=10}
graph <- violinplot_comp(bv_p22_t1, qpv_p22_t1, "au premier tour des présidentielles de 2022", "", 0, 80)
graph
saving_plot(graph, "violin_p22_t1", 7, 10)
```

### Pres.22 tour 2

```{r fig.height=5}
graph <- violinplot_comp(bv_p22_t2, qpv_p22_t2, "au second tour des présidentielles de 2022", "", 0, 80)
graph
saving_plot(graph, "violin_p22_t2", 7, 6)
```

### Leg.22 tour 1

```{r fig.height=10}
graph <- violinplot_comp(bv_l22_t1, qpv_l22_t1, "au premier tour des législatives de 2017", "", 0, 80)
graph
saving_plot(graph, "violin_l22_t1", 7, 10)
```


## Moyenne des votes{.tabset}

### Pres.17 tour 1

```{r fig.height=10}
graph <- barplot_comp(bv_p17_t1, qpv_p17_t1, "au premier tour des présidentielles de 2017", "L'abstention est beaucoup plus élevée dans les QPV,\net le vote y est plus orienté à gauche.", 0, 40)
graph
saving_plot(graph, "bar_p17_t1", 7, 10)
```



## Cartographies des votes{.tabset}

### Pres.17 tour 1

<iframe src="Save_cartos/carte_p17_t1.html" height="600" width="1000" style="border: 0px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe>


### Pres.17 tour 2

<iframe src="Save_cartos/carte_p17_t2.html" height="600" width="1000" style="border: 0px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe>


### Leg.17 tour 1

<iframe src="Save_cartos/carte_l17_t1.html" height="600" width="1000" style="border: 0px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe>


### Pres.22 tour 1

<iframe src="Save_cartos/carte_p22_t1.html" height="600" width="1000" style="border: 0px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe>


### Pres.22 tour 2

<iframe src="Save_cartos/carte_p22_t2.html" height="600" width="1000" style="border: 0px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe>


### Leg.22 tour 1

<iframe src="Save_cartos/carte_l22_t1.html" height="600" width="1000" style="border: 0px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe>




# Analyse en composantes principales

```{r code ACP}
# il faut conduire l'ACP sur des pourcentages, pas des valeurs absolues (sinon tout est écrasé par l'effet volume)

#- ACP avec en 
#- individus actifs : les BV en 2017 
    #variables actives : les résultats pour P17T1, P17T2 
    #variables supplémentaires: les résultats pour L17T1, P22T1, P22T2, L22T1
#- individus supplémentaires : les BV 2022 et les QPV (2017 et 2022)
 #(éventuellement en pondérant les individus statistiques par le nombre d'inscrits, mais ça ne devrait pas changer grand chose)


# Préparation des données
var_actives <- left_join(as.data.frame(bv_p17_t1) |> rename_at(vars(-bureau_vote_id), ~ paste0(., '_p17_t1')), 
                         as.data.frame(bv_p17_t2) |> mutate(across(Abstentions:`LE.PEN`, ~ . / Inscrits * 100, .names = "{.col}_ins")) |> rename_at(vars(-bureau_vote_id), ~ paste0(., '_p17_t2')), 
                         by = 'bureau_vote_id')  |> 
    select(bureau_vote_id, contains(c("_ins", ".ins")), -contains("code_insee"), -contains(c("votants", "Votants", "Exprimés", "exprimés")))
var_supp_pre <- left_join(as.data.frame(bv_p22_t1) |> rename_at(vars(-bureau_vote_id), ~ paste0(., '_p22_t1')), 
                          as.data.frame(bv_p22_t2) |> rename_at(vars(-bureau_vote_id), ~ paste0(., '_p22_t2')), 
                          by = 'bureau_vote_id') |> 
    select(bureau_vote_id, contains(c("_ins", ".ins")), -contains("code_insee"), -contains(c("votants", "Votants", "Exprimés", "exprimés")))
var_supp_leg <- left_join(as.data.frame(bv_l17_t1) |> rename_at(vars(-bureau_vote_id), ~ paste0(., '_l17_t1')), 
                          as.data.frame(bv_l22_t1) |> rename_at(vars(-bureau_vote_id), ~ paste0(., '_l22_t1')), 
                          by = 'bureau_vote_id')  |> 
    select(bureau_vote_id, contains(c("_ins", ".ins")), -contains("code_insee"), -contains(c("votants", "Votants", "Exprimés", "exprimés")))
var_supp <- full_join(var_supp_pre, var_supp_leg, by = 'bureau_vote_id')
var_acp <- full_join(var_actives, var_supp, by = 'bureau_vote_id') |> 
    select(-starts_with(c("code_insee", "CodeInsee", "CodeDepartement", "Département", "CodeCirco", "Commune", "NumeroBV", "geom", "id_", "Code.du.département", "type", "Code.de.la.circonscription", "Code.de.la.commune", "Code.du.b.vote", "NbCand", "NumeroCirco", "CodeCommune"))) |>
    column_to_rownames("bureau_vote_id") |>
    rename_with(~ str_replace(., "[\\._]ins", ""))

# ACP sans variables quanti supp
var_acp_sans_sup <- var_acp |> select(contains("p17"))
res.pca <- PCA(var_acp_sans_sup, graph=FALSE)

# Thème custom des graphs de sortie pour plus de lisibilité
theme_acp_1.2 <- function(plot, xmin, xmax, ymin, ymax, titre,
                          x_abs, y_abs, x_macr, y_macr, x_EXD, y_EXD, x_EXG, y_EXG){
    plot + 
    geom_label(aes(x = x_abs, y = y_abs), hjust = 0.5, label = "Abstention", label.size = NA, size = 4) +
    geom_label(aes(x = x_macr, y = y_macr), hjust = 0.5, label = "Droite et Macron", label.size = NA, size = 4) +
    geom_label(aes(x = x_EXD, y = y_EXD), hjust = 0, label = "Extrême \ndroite", label.size = NA, size = 4) +
    geom_label(aes(x = x_EXG, y = y_EXG), hjust = 1, label = "Gauche", label.size = NA, size = 4) +
    xlim(xmin, xmax) +
    ylim(ymin, ymax) + 
    coord_flip() +
    scale_x_continuous(trans = "reverse") +
    labs(x = "Dimension 1 (29.1%)", y = "Dimension 2 (19.1%)",
         title = titre)
}
```

#### Variance expliquée

```{r variance, out.width='60%'}
    # Scree plot
var <- get_pca_var(res.pca)
graph <- fviz_screeplot(res.pca, addlabels = TRUE, ylim = c (0, 45))
graph
saving_plot(graph, "ACP_variance_expliquee", 8, 6)
```

#### Variables{.tabset}

##### Dimensions 1 et 2

```{r}
graph <- fviz_pca_var(res.pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE, 
             ggtheme = theme_minimal()) |> 
    theme_acp_1.2(titre = "Projection des variables sur les deux premières dimensions",
                  xmin = -1.2, xmax = 1.2, ymin = -1.3, ymax = 1.4,
                  x_abs = 1.15, y_abs = 0, x_macr = -1.15, y_macr = 0, x_EXD = 0, y_EXD = 1.05, x_EXG = 0, y_EXG = -1.05) +
    scale_color_gradient2(name = "Qualité de \nreprésentation", midpoint = .5,
                          low="#00AFBB", mid = "#E7B800", high="#FC4E07")
graph
saving_plot(graph, "ACP_var_dim1.2", 8, 6)
```


##### Dimensions 1 et 3

```{r}
graph <- fviz_pca_var(res.pca, col.var = "cos2",
             axes = c(1, 3),
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE, 
             ggtheme = theme_minimal()) #|> 
    #theme_acp_1.3(titre = "Projection des variables sur les dimensions 1 et 3")
graph
saving_plot(graph, "ACP_var_dim1.2", 8, 6)
```


#### Qualité de représentation (cosinus carrés){.tabset}

```{r cos2}
#les variables sont biens représentées par chaque axe (sauf l'axe 3)
corrplot(var$cos2, is.corr=FALSE)
```


##### Dimension 1

```{r cos2.1, out.width='60%'}
graph <- fviz_cos2(res.pca, choice = "var", axes = 1, top = 15)
graph
saving_plot(graph, "ACP_cos2_dim1", 9, 6)
```

##### Dimension 2


```{r cos2.2, out.width='60%'}
graph <- fviz_cos2(res.pca, choice = "var", axes = 2, top = 15)
graph
saving_plot(graph, "ACP_cos2_dim2", 9, 6)
```

##### Dimension 3

```{r cos2.3, out.width='60%'}
graph <- fviz_cos2(res.pca, choice = "var", axes = 3, top = 15)
graph
saving_plot(graph, "ACP_cos2_dim3", 9, 6)
```



#### Contribution des variables aux dimensions{.tabset}
 
```{r contrib}
# contribution de chaque variable à la formation des axes 1 et 2 
corrplot(var$contrib, is.corr=FALSE)    
```

##### Dimension 1

```{r contrib.1, out.width='60%'}
graph <- fviz_contrib(res.pca, choice = "var", axes = 1, top = 15)
graph
saving_plot(graph, "ACP_contrib_dim1", 9, 6)
```

##### Dimension 2


```{r contrib.2, out.width='60%'}
graph <- fviz_contrib(res.pca, choice = "var", axes = 2, top = 15)
graph
saving_plot(graph, "ACP_contrib_dim2", 9, 6)
```

##### Dimension 3

```{r contrib.3, out.width='60%'}
graph <- fviz_contrib(res.pca, choice = "var", axes = 3, top = 15)
graph
saving_plot(graph, "ACP_contrib_dim3", 9, 6)
```



#### Description des dimensions{.tabset}

##### Dimension 1

```{r dimdesc.1}
res.desc <- dimdesc(res.pca, axes = c(1,2,3))
as.data.frame(res.desc$Dim.1) |> rownames_to_column() |> na.omit() |> 
    gt::gt() |> gt::fmt_number(columns = 2:3, decimals = 2)
```

##### Dimension 2


```{r dimdesc.2}
as.data.frame(res.desc$Dim.2) |> rownames_to_column() |> na.omit() |> 
    gt::gt() |> gt::fmt_number(columns = 2:3, decimals = 2)
```

##### Dimension 3

```{r dimdesc.3}
as.data.frame(res.desc$Dim.3) |> rownames_to_column() |> na.omit() |> 
    gt::gt() |> gt::fmt_number(columns = 2:3, decimals = 2)
```



#### Projection des individus{.tabset}

##### Dimensions 1 et 2

```{r individus, out.width='60%'}
graph <- fviz_pca_ind(res.pca, 
             col.ind = "cos2", 
             axes = c(1, 2),
             select.ind = list("cos2" = 25),
             label = "ind", #masquer le texte des individus
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE) |> 
    theme_acp_1.2("Projection des 25 BV les mieux représentés sur les deux premières dimensions",
                  xmin = -5, xmax = 7, ymin = -6, ymax = 8.6,
                  x_abs = 6.9, y_abs = 0, x_macr = -5.9, y_macr = 0, x_EXD = 0, y_EXD = 6.9, x_EXG = 0, y_EXG = -4.5) +
    scale_color_gradient2(name = "Qualité de \nreprésentation", midpoint = .85,
                          low="#00AFBB", mid = "#E7B800", high="#FC4E07")
graph
saving_plot(graph, "ACP_individus_1.2", 8, 6)
```


##### Dimensions 1 et 3

```{r, out.width='60%'}
fviz_pca_ind(res.pca, 
             col.ind = "cos2", 
             axes = c(1, 3),
             select.ind = list("cos2" = 25),
             label = "ind", #masquer le texte des individus
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
graph
saving_plot(graph, "ACP_individus_1.3", 8, 6)
```

##### Variables et individus

```{r biplot}
graph <- fviz_pca_biplot(res.pca, 
                repel = TRUE,
                label = "var", #masquer le texte des individus
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969",  # Individuals color,
                alpha.ind = "cos2"
                ) |> 
    theme_acp_1.2("Projection des BV et des variables sur les deux premières dimensions",
                  xmin = -8, xmax = 8, ymin = -6, ymax = 8,
                  x_abs = 7.5, y_abs = 0, x_macr = -7.5, y_macr = 0, x_EXD = 0, y_EXD = 6.9, x_EXG = 0, y_EXG = -5)# +
    #scale_color_gradient2(name = "Qualité de \nreprésentation", midpoint = .85,
    #                      low="#00AFBB", mid = "#E7B800", high="#FC4E07")
graph
saving_plot(graph, "ACP_individus_variables_1.2", 8, 6)
```

```{r biplot13, eval=FALSE, include=FALSE}
fviz_pca_biplot(res.pca, 
                axes = c(1,3),
                repel = TRUE,
                label = "var", #masquer le texte des individus
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969",  # Individuals color,
                alpha.ind = "cos2"
                )
```


#### Variables supplémentaires

```{r quanti.sup}
res.pca_quanti.sup <- PCA(var_acp, quanti.sup=20:79, graph=FALSE)
    #graph
graph <- fviz_pca_var(res.pca_quanti.sup,
             col.var = "black",     # Active variables
             col.quanti.sup = "red", # Suppl. quantitative variables
             select.var = list(cos2 = 25)
             ) |> 
    theme_acp_1.2(titre = "Projection des variables supplémentaires sur les deux premières dimensions",
                  xmin = -1.2, xmax = 1.2, ymin = -1.3, ymax = 1.4,
                  x_abs = 1.15, y_abs = 0, x_macr = -1.15, y_macr = 0, x_EXD = 0, y_EXD = 1.05, x_EXG = 0, y_EXG = -1.05)
graph
saving_plot(graph, "ACP_variables_supplementaires", 8, 6)
```

#### Individus supplémentaires{.tabset}

```{r ind.sup prepa}
# Préparation des données
var_actives_qpv <- left_join(as.data.frame(qpv_p17_t1) |> rename_at(vars(-CODE_QP), ~ paste0(., '_p17_t1')), 
                         as.data.frame(qpv_p17_t2) |> rename_at(vars(-CODE_QP), ~ paste0(., '_p17_t2')), 
                         by = 'CODE_QP') |> 
    select(-contains(c("_ins", ".ins"))) |> 
    mutate(across(c(Abstentions_p17_t1:FILLON_p17_t1, Abstentions_p17_t2:LE.PEN_p17_t2), ~ . / Inscrits_p17_t1 * 100, .names = "{.col}.ins")) |>
    select(CODE_QP, contains(c("_ins", ".ins")), -contains("code_insee"), -contains(c("votants", "Votants", "Exprimés", "exprimés")))
var_supp_pre_qpv <- left_join(as.data.frame(qpv_p22_t1) |> rename_at(vars(-CODE_QP), ~ paste0(., '_p22_t1')), 
                          as.data.frame(qpv_p22_t2) |> rename_at(vars(-CODE_QP), ~ paste0(., '_p22_t2')), 
                          by = 'CODE_QP') |> 
    mutate(across(c(Abstentions_p22_t1:DUPONT.AIGNAN_p22_t1, Abstentions_p22_t2:LE.PEN_p22_t2), ~ . / Inscrits_p22_t1 * 100, .names = "{.col}.ins")) |>
    select(CODE_QP, contains(c("_ins", ".ins")), -contains("code_insee"), -contains(c("votants", "Votants", "Exprimés", "exprimés")))
var_supp_leg_qpv <- left_join(as.data.frame(qpv_l17_t1) |> rename_at(vars(-CODE_QP), ~ paste0(., '_l17_t1')), 
                          as.data.frame(qpv_l22_t1) |> rename_at(vars(-CODE_QP), ~ paste0(., '_l22_t1')), 
                          by = 'CODE_QP') |> 
    mutate(across(c(Abstentions_l17_t1:EXD_l17_t1), ~ . / Inscrits_l17_t1 * 100, .names = "{.col}.ins")) |>
    mutate(across(c(Abstentions_l22_t1:EXD_l22_t1), ~ . / Inscrits_l22_t1 * 100, .names = "{.col}.ins")) |>
    select(CODE_QP, contains(c("_ins", ".ins")), -contains("code_insee"), -contains(c("votants", "Votants", "Exprimés", "exprimés")))
var_supp_qpv <- full_join(var_supp_pre_qpv, var_supp_leg_qpv, by = 'CODE_QP') 
var_acp_qpv <- full_join(var_actives_qpv, var_supp_qpv, by = 'CODE_QP') |> 
    rename_with(~ str_replace(., "[\\._]ins", "")) |>
    column_to_rownames("CODE_QP")
ensemble <- rbind(var_acp |> mutate(type = "Tous BV"),
                  var_acp_qpv |> mutate(type = "QPV"))
```

##### Dimensions 1 et 2

```{r}
res.pca_ind.sup <- PCA(ensemble[,-80], ind.sup=890:926, quanti.sup=20:79, graph=T, axes = c(1, 2))
```

##### Dimensions 1 et 3

```{r}
# ACP en intégrant les QPV en individus supplémentaires
res.pca_ind.sup <- PCA(ensemble[,-80], ind.sup=890:926, quanti.sup=20:79, graph=T, axes = c(1, 3))
```

#### Couleurs par type

```{r version interactive}
res.pca_all <- PCA(ensemble[,-80], graph = FALSE)
graph <- left_join(ensemble |> select(type) |> rownames_to_column(),
                  res.pca_all$ind$coord |> as.data.frame() |> rownames_to_column(), by = "rowname") |> 
    left_join(pop_qpv |> select(codeQPV, libQPV, listeLibDepcom) |> 
                  rename(id = codeQPV, nom = libQPV, commune = listeLibDepcom),
              by = c("rowname" = "id")) |> 
    ggplot() +
    geom_point(aes(x = Dim.1, y = Dim.2, group = type, color = type, shape = type, 
                   text = ifelse(type == "QPV",
                                 paste0("QPV n°", rowname, "\nNom : ", nom, "\nCommune : ", commune),
                                 paste0("BV n°", rowname)))) +
    stat_ellipse(aes(x = Dim.1, y = Dim.2, group = type, color = type, fill = type), type = "norm") +
    theme_minimal() +
    scale_color_manual(name = "", values = c("Tous BV" = "wheat2", "QPV" = "brown3")) +
    scale_fill_manual(name = "", values = c("Tous BV" = "wheat2", "QPV" = "brown3")) +
    geom_hline(aes(yintercept = 0), linetype = "dashed") +
    geom_vline(aes(xintercept = 0), linetype = "dashed") +
    geom_text(aes(x = 13, y = 0), hjust = 0.5, label = "Abstention", label.size = NA, size = 4) +
    geom_text(aes(x = -11, y = 0), hjust = 0.5, label = "Droite et Macron", label.size = NA, size = 4) +
    geom_text(aes(x = 0, y = 9), hjust = 0, label = "Extrême \ndroite", label.size = NA, size = 4) +
    geom_text(aes(x = -.5, y = -9), hjust = 1, label = "Gauche", fill = "white", size = 4) +
    xlim(-12, 13.5) +
    ylim(-11, 12) + 
    coord_flip() +
    scale_x_continuous(trans = "reverse") +
    labs(x = "Dimension 1 (29.1%)", y = "Dimension 2 (19.1%)",
         title = "Projection des BV et QPV sur les deux premières dimensions") +
    guides(fill = "none", shape = "none", alpha = "none", 
           color = guide_legend(label.vjust = 1)) 
ggplty <- ggplotly(graph, tooltip = "text")
ggplty
htmlwidgets::saveWidget(
                widget = ggplty, #the plotly object
                file = "Save_graphs/couleurs_par_type.html", #the path & file name
                selfcontained = TRUE #creates a single html file
                )
```

```{r}
#- comparaison de la distribution du vote pour chaque comportement principal par BV entre l'ensemble des BV de la Métropole et les QPV (avec `geom_dotplot` par exemple)

# Evolution du vote au sein des QPV

#- graphique avec en abscisse 4 scrutins (P17T1, L17T1, P22T1, L22T1) et en ordonnée le vote, et une ligne par grand comportement électoral (ou alors un graphique par comportement électoral, avec `geom_facet`, ce qui permet de rajouter en repère le comportement national et celui de l'ensemble de la Métropole de Lyon) 
```

#### Clusters de variables

```{r}
# Kmeans
    # Preparation
set.seed(123)
res.km <- kmeans(var$coord, centers = 3, nstart = 25)
grp <- as.factor(res.km$cluster)
    # Color variables by groups
graph <- fviz_pca_var(res.pca, col.var = grp, 
             palette = c("#0073C2FF", "#EFC000FF", "#868686FF"),
             legend.title = "Cluster") |> 
    theme_acp_1.2(titre = "Projection des variables regroupées par cluster",
                  xmin = -1.2, xmax = 1.2, ymin = -1.3, ymax = 1.4,
                  x_abs = 1.15, y_abs = 0, x_macr = -1.15, y_macr = 0, x_EXD = 0, y_EXD = 1.05, x_EXG = 0, y_EXG = -1.05)# +
graph
saving_plot(graph, "ACP_clusters", 8, 6)
```


```{r eval=FALSE, include=FALSE}
res.hcpc <- HCPC (res.pca, graph = FALSE, max = 3)
fviz_dend(res.hcpc, show_labels = FALSE)
# Individuals facor map
fviz_cluster(res.hcpc, geom = "point", main = "Factor map")


res.hcpc <- HCPC(res.pca, nb.clust = 0, min = 3, max = 10, graph = F)
fviz_dend(res.hcpc, 
          cex = 0.7,                     # Label size
          palette = "jco",               # Color palette see ?ggpubr::ggpar
          rect = TRUE, rect_fill = TRUE, # Add rectangle around groups
          rect_border = "jco",           # Rectangle color
          labels_track_height = 0.8      # Augment the room for labels
          )

fviz_cluster(res.hcpc,
             repel = TRUE,            # Avoid label overlapping
             show.clust.cent = TRUE, # Show cluster centers
             palette = "jco",         # Color palette see ?ggpubr::ggpar
             ggtheme = theme_minimal(),
             main = "Factor map"
             )

par(mar=c(1,1,1,7))
dend %>%
  set("labels_col", value = c("skyblue", "orange", "grey"), k=3) %>%
  set("branches_k_color", value = c("skyblue", "orange", "grey"), k = 3) %>%
  plot(horiz=TRUE, axes=FALSE)
abline(v = 350, lty = 2)
```



