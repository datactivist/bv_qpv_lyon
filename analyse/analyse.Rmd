---
title: "Le vote des QPV"
subtitle: "dans la métropole de Lyon"
author: "Auteur"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
    rmarkdown::html_document:
      #number_sections: true
      theme: paper
      toc: true
      toc_depth: 4
      collapsed: true
      smooth_scroll: true
      css: styles.css
      includes:
        in_header: header.html
        after_body: footer.html
---

```{r setup, include=FALSE}
# Paramètres généraux
knitr::opts_chunk$set(
	eval = TRUE,
	echo = FALSE,
	fig.align = "center",
	fig.show = "hold",
	message = FALSE,
	warning = FALSE,
	collapse = TRUE,
	out.width = "100%",
	results = "asis"
)
```

```{r logo}
# Logo Datactivist haut de page
htmltools::img(src = "https://nextcloud.datactivist.coop/s/o53wzfMNnFosQni/preview", 
               alt = 'logo', 
               style = 'position:absolute; top:0; left:0.5; padding-top:10px;') #padding=taille des espaces autour
```

```{r packages}
library(sf)
library(httr)
library(here)
library(tidyverse)
```


# Calcul des contours des BV

- on va utiliser ce qui existe déjà, en open data ou dans Cartelec (mais a priori Cartelec ne va pas beaucoup aider). 
- on n'a ainsi besoin de calculer les contours des BV uniquement pour les communes pas couvertes par open data ou Cartelec ET dans lesquelles il y a un QPV.

```{r communes_grand_lyon}

communes_gd_lyon <- read_csv2("https://download.data.grandlyon.com/ws/grandlyon/adr_voie_lieu.adrcomgl/all.csv?maxfeatures=100&start=1")

communes_gd_lyon_shp <- GET(URLencode("https://download.data.grandlyon.com/wfs/grandlyon?SERVICE=WFS&VERSION=2.0.0&request=GetFeature&typename=adr_voie_lieu.adrcomgl&outputFormat=application/json; subtype=geojson&SRSNAME=EPSG:4171"))
communes_gd_lyon_shp <- content(communes_gd_lyon_shp, as = "text")
communes_gd_lyon_shp <- st_read(communes_gd_lyon_shp, drivers = "GeoJSON", quiet = TRUE)

```

```{r open_data_2022}
bv_gd_lyon_OD_2022 <- GET(URLencode("https://download.data.grandlyon.com/wfs/grandlyon?SERVICE=WFS&VERSION=2.0.0&request=GetFeature&typename=ter_territoire.terbureauvoteperim&outputFormat=application/json; subtype=geojson&SRSNAME=EPSG:4171"))

bv_gd_lyon_OD_2022 <- content(bv_gd_lyon_OD_2022, as = "text")
bv_gd_lyon_OD_2022 <- st_read(bv_gd_lyon_OD_2022, quiet = TRUE)

# enlever les rues dont on n'a pas besoin
bv_gd_lyon_OD_2022 <- bv_gd_lyon_OD_2022 %>% 
  select(-rues)

# communes pour lesquelles on dispose des données

communes_OD_2022 <- bv_gd_lyon_OD_2022 %>% 
  as_tibble() %>% 
  distinct(insee, commune)

# attention à Lyon (commune : 69123 vs arrondissements : 69381 à 69389)
communes_OD_2022 <- communes_OD_2022 %>% 
  mutate(insee = case_when(insee %in% as.character(69381:69389) ~ "69123",
                           TRUE ~ insee)) %>% 
  distinct(insee)

```

```{r cartelec}

cartelec_2017 <- st_read(here("data", "bv_2017.gpkg"))
cartelec_2017 <- cartelec_2017 %>% st_transform(4326)
communes_cartelec_2017 <- cartelec_2017 %>% 
  filter(codedep %in% "69") %>% 
  as_tibble() %>% 
  distinct(CodeINSEE, libelle_commune)
communes_cartelec_2017 <- communes_cartelec_2017 %>% 
  mutate(CodeINSEE = case_when(CodeINSEE %in% as.character(69381:69389) ~ "69123",
                           TRUE ~ CodeINSEE))
```

```{r qpv}

qpv <- st_read(here("data", "QP_METROPOLE_LB93.shp"), quiet = TRUE)
communes_qpv <- communes_gd_lyon_shp %>% 
  st_transform(st_crs(qpv)) %>% 
  st_intersects(qpv)
communes_qpv <- communes_gd_lyon_shp %>% 
  as_tibble() %>% 
  filter(map_lgl(communes_qpv, ~ length(.) > 0))
qpv <- st_transform(qpv, 4326)
  
```


```{r a_produire}

# on produit pour toutes les communes du Grand Lyon car sinon on a un problème d'hétérogénéité à gérer

# 2022
aproduire_2022 <- communes_gd_lyon %>% # communes du grand lyon
  mutate(insee = as.character(insee)) %>% 
  anti_join(communes_OD_2022, by = "insee")  # qui ne sont pas déjà couvertes en OD

# 2017
aproduire_2017 <- communes_gd_lyon %>% # communes du grand lyon
  mutate(insee = as.character(insee)) %>% 
  anti_join(communes_cartelec_2017, by = c("insee" = "CodeINSEE"))  # qui ne sont pas déjà couvertes en OD

```

```{r import_listes_2017}
# dans le fichier original quelques guillemets trainaient, on les supprime :
# sed 's/"//g' liste\ électorale\ 2017\ Rhône.csv > liste_electorale_2017.csv
liste_2017 <- read_csv2(here("data/listes électorales", "liste_electorale_2017.csv"), col_select = c("numéro du bureau de vote", "NumeroVoie", "LibelleVoie", "Code postal", "VilleLocalite", "Code INSEE"), col_types = "cccccc")
```

```{r import_listes_2022}
codes <- aproduire_2022 %>% magrittr::extract2("insee")

fichiers <- fs::dir_ls(here("data", "listes électorales", "listes 2022"))
fichiers <- fichiers[str_detect(fichiers, paste0(codes, collapse = "|"))]

liste_2022 <- map_df(fichiers, 
                     ~ read_csv2(., col_select = c("code du bureau de vote", "numéro de voie", "libellé de voie", "code postal", "commune"), col_types = cols(.default = col_character())))

# le code insee n'est pas fourni par défaut... on le rajoute

source(here("functions", "match_commune.R"))

mem_match_commune <- memoise::memoise(match_commune, cache = memoise::cache_filesystem(here("cache")))

liste_2022 <- liste_2022 %>% 
  rowwise() %>% 
  mutate(code_insee = mem_match_commune(commune, "69")) %>% 
  filter(!is.na(code_insee)) %>% 
  ungroup()

```


```{r source_create_bv}
source(here("functions", "create_bv.R"))
mem_create_bv <- memoise::memoise(create_bv, cache = memoise::cache_filesystem(here("cache")))
```


```{r calcul_bv_2017}

bv_2017_produits <- aproduire_2017 %>% 
  magrittr::extract2("insee") %>% 
  map_df(~ create_bv(liste_2017, code_insee_commune = ., seuil = 0.6))

st_write(bv_2017_produits, here("output_data", "bv_produits_2017.gpkg"))

```

```{r weights_2017}

poids_2017 <- liste_2017 %>% 
  mutate(bv = as.character(`numéro du bureau de vote`)) %>% 
  mutate(adresse = paste0(NumeroVoie, " ", LibelleVoie)) %>% 
  count(adresse, `Code INSEE`) %>% 
  banR::geocode_tbl(adresse = adresse, code_insee = `Code INSEE`)
poids_2017 <- poids_2017 %>% 
    filter(!is.na(longitude), !is.na(latitude)) %>% 
    st_as_sf(coords = c("longitude", "latitude")) %>% 
    st_set_crs(4326)

```


```{r calcul_bv_2022}

bv_2022_produits <- aproduire_2022 %>% 
  magrittr::extract2("insee") %>% 
  map_df(~ create_bv(liste_2022, code_insee_commune = ., seuil = 0.6, code_insee = code_insee, numero_voie = `numéro de voie`, libelle_voie = `libellé de voie`, code_bv = `code du bureau de vote`))
st_write(bv_2022_produits, here("output_data", "bv_produits_2022.gpkg"))
# bv_2022_produits <- st_read(here("output_data", "bv_produits_2022.gpkg"))
```

```{r assemblage_2017}
bv_2017 <- bind_rows(
  bv_2017_produits %>% 
    mutate(code_insee = str_sub(bureau_vote_id, 1, 5)) %>% 
    rename(geom = voronois),
  cartelec_2017 %>% 
    filter(codedep %in% "69") %>% 
    select(code_insee = CodeINSEE, bureau_vote_id, geom)
  )

bv_communes_2017 <- bind_rows(
  bv_2017 %>% 
    mutate(id = bureau_vote_id, 
           type = "bv"),
  communes_gd_lyon_shp %>% 
    anti_join(aproduire_2017, by = "insee") %>% 
    anti_join(communes_cartelec_2017, by = c("insee" = "CodeINSEE")) %>% 
    select(code_insee = insee, geom = geometry) %>% 
    mutate(id = code_insee,
           type = "commune")
)
st_write(bv_communes_2017, here("output_data", "bv_communes_2017.gpkg"))
# bv_communes_2017 <- st_read(here("output_data", "bv_communes_2017.gpkg"))
```

```{r assemblage_2022}
bv_2022 <- bind_rows(
  bv_2022_produits %>% 
    mutate(code_insee = str_sub(bureau_vote_id, 1, 5)) %>% 
    rename(geom = voronois),
  bv_gd_lyon_OD_2022 %>% 
    mutate(bureau_vote_id = paste0(insee, str_pad(numero, 4, "left", "0"))) %>% 
    select(code_insee = insee, bureau_vote_id, geom = geometry)
  )

bv_communes_2022 <- bind_rows(
  bv_2022 %>% 
    mutate(id = bureau_vote_id, 
           type = "bv"),
  communes_gd_lyon_shp %>% 
    anti_join(aproduire_2022, by = "insee") %>% 
    anti_join(communes_OD_2022, by = "insee") %>% 
    select(code_insee = insee, geom = geometry) %>% 
    mutate(id = code_insee,
           type = "commune")
)
st_write(bv_communes_2022, here("output_data", "bv_communes_2022.gpkg"))
# bv_communes_2022 <- st_read(here("output_data", "bv_communes_2022.gpkg"))
```

```{r import_elections}

# présidentielles 2017 T1

presidentielle_2017_t1_bv <- read_csv("https://www.data.gouv.fr/fr/datasets/r/f4c23dab-46ff-4799-b217-1ab29db7938b")

# législatives 2017 T1

download.file("https://www.data.gouv.fr/fr/datasets/r/80cb1309-9147-4bae-b6e2-79877d549b50", destfile = here("data", "legislatives_2017_T1_bv.csv"))

header_L17T1 <- names(read_csv2(here("data", "legislatives_2017_T1_bv.csv"), locale = locale(encoding = "ISO-8859-1"), n_max = 1))
n_col <- ncol(read_csv2(here("data", "legislatives_2017_T1_bv.csv"), locale = locale(encoding = "ISO-8859-1"), skip = 1, col_names =FALSE))
nrep <- (n_col-21) / 8
legislatives_2017_t1_bv <- read_csv2(here("data", "legislatives_2017_T1_bv.csv"), locale = locale(encoding = "ISO-8859-1"), skip = 1, col_names = c(header_L17T1[-c(22:29)], paste0(rep(c("no_panneau", "sexe", "nom", "prenom", "nuance", "voix", "voix_ins", "voix_exp"), nrep), "_", rep(seq(1:nrep), each = 8))))

leg_2017_R1_BV_cleaned <- LireMinInterieur::lire(legislatives_2017_t1_bv, keep = names(legislatives_2017_t1_bv)[c(1,3,5,7:9,11,13,16,19)], col = seq(26, n_col, 8), gap = 1)

leg_2017_R1_BV_cleaned <- leg_2017_R1_BV_cleaned %>% 
  mutate(CodeDepartement = str_pad(string = `Code du département`, width = 2, side = "left", pad = "0")) %>% # has to be in a format like "02"
  mutate(NumeroCirco = str_pad(`Code de la circonscription`, 2, "left", "0")) %>%
  mutate(CodeCirco = paste0(CodeDepartement, NumeroCirco)) %>% 
  mutate(CodeCommune = str_pad(string = `Code de la commune`, width = 3, side = "left", pad = "0")) %>% 
  mutate(CodeInsee = paste0(CodeDepartement, CodeCommune)) %>%  # unique commune ID
  # computing missing values
  mutate(NumeroBV = str_pad(`Code du b.vote`, width = "4", side = "left", pad = "0")) %>% 
  mutate(CodeBV = paste0(CodeInsee, NumeroBV)) %>% 
  mutate(Votants = Inscrits - Abstentions) %>% 
  mutate(Votants_ins = Votants / Inscrits * 100) %>% 
  mutate(Abstentions_ins = Abstentions / Inscrits * 100) %>% 
  mutate(Blancs_ins = Blancs/ Inscrits * 100) %>% 
  mutate(Blancs_vot = Blancs / Votants * 100) %>% 
  mutate(Nuls_ins = Nuls / Inscrits * 100) %>% 
  mutate(Nuls_vot = Nuls / Votants * 100) %>% 
  mutate(Exprimés_ins = Exprimés / Inscrits * 100) %>% 
  mutate (Exprimés_vot = Exprimés / Votants * 100) %>% 
  # specify integers %>% 
  mutate_at(vars(Inscrits, Abstentions, Votants, Blancs, Nuls, Exprimés, EXG:EXD), as.integer) %>% 
  as_tibble()

leg_2017_R1_BV_cleaned %>% write_excel_csv(here("data", "leg_2017_t1_bv.csv"))

# read_csv(here("data", "leg_2017_t1_bv.csv"))

```


```{r repartition_qpv}

# on peut maintenant calculer le vote des QPV

# il faut d'abord matcher les bv avec les résultats 2017

bv_grandyon_p2017_t1_res <- bv_communes_2017 %>% 
  mutate(bureau_vote_id = str_replace(bureau_vote_id, "6938[1-9]", "69123")) %>% 
  left_join(presidentielle_2017_t1_bv, by = join_by(bureau_vote_id == CodeBV)) %>% 
  filter(!is.na(Inscrits))

qpv69 <- qpv %>% 
  filter(str_detect(CODE_QP, "QP069"))

# l'une des géométries est invalide. Il a fallu la modifier manuellement avec QGIS.

rm(qpv69)
qpv69 <- st_read(here("data", "qpv69.gpkg"))
qpv_gd_lyon <- qpv69 %>% slice(which(map_lgl(qpv69 %>% st_intersects(communes_gd_lyon_shp), ~ !is_empty(.))))


# puis procéder à la répartition
qpv69_pres_17_t1 <- tidycensus::interpolate_pw(from = bv_grandyon_p2017_t1_res %>% select(- contains("_ins"), -contains("_exp"), -contains("_vot")), to = qpv_gd_lyon, to_id = "CODE_QP", extensive = TRUE, weights = poids_2017, weight_column = "n")


```

